#define _CFFI_

/* We try to define Py_LIMITED_API before including Python.h.

   Mess: we can only define it if Py_DEBUG, Py_TRACE_REFS and
   Py_REF_DEBUG are not defined.  This is a best-effort approximation:
   we can learn about Py_DEBUG from pyconfig.h, but it is unclear if
   the same works for the other two macros.  Py_DEBUG implies them,
   but not the other way around.
*/
#ifndef _CFFI_USE_EMBEDDING
#  include <pyconfig.h>
#  if !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG)
#    define Py_LIMITED_API
#  endif
#endif

#include <Python.h>
#ifdef __cplusplus
extern "C" {
#endif
#include <stddef.h>

/* This part is from file 'cffi/parse_c_type.h'.  It is copied at the
   beginning of C sources generated by CFFI's ffi.set_source(). */

typedef void *_cffi_opcode_t;

#define _CFFI_OP(opcode, arg)   (_cffi_opcode_t)(opcode | (((uintptr_t)(arg)) << 8))
#define _CFFI_GETOP(cffi_opcode)    ((unsigned char)(uintptr_t)cffi_opcode)
#define _CFFI_GETARG(cffi_opcode)   (((intptr_t)cffi_opcode) >> 8)

#define _CFFI_OP_PRIMITIVE       1
#define _CFFI_OP_POINTER         3
#define _CFFI_OP_ARRAY           5
#define _CFFI_OP_OPEN_ARRAY      7
#define _CFFI_OP_STRUCT_UNION    9
#define _CFFI_OP_ENUM           11
#define _CFFI_OP_FUNCTION       13
#define _CFFI_OP_FUNCTION_END   15
#define _CFFI_OP_NOOP           17
#define _CFFI_OP_BITFIELD       19
#define _CFFI_OP_TYPENAME       21
#define _CFFI_OP_CPYTHON_BLTN_V 23   // varargs
#define _CFFI_OP_CPYTHON_BLTN_N 25   // noargs
#define _CFFI_OP_CPYTHON_BLTN_O 27   // O  (i.e. a single arg)
#define _CFFI_OP_CONSTANT       29
#define _CFFI_OP_CONSTANT_INT   31
#define _CFFI_OP_GLOBAL_VAR     33
#define _CFFI_OP_DLOPEN_FUNC    35
#define _CFFI_OP_DLOPEN_CONST   37
#define _CFFI_OP_GLOBAL_VAR_F   39
#define _CFFI_OP_EXTERN_PYTHON  41

#define _CFFI_PRIM_VOID          0
#define _CFFI_PRIM_BOOL          1
#define _CFFI_PRIM_CHAR          2
#define _CFFI_PRIM_SCHAR         3
#define _CFFI_PRIM_UCHAR         4
#define _CFFI_PRIM_SHORT         5
#define _CFFI_PRIM_USHORT        6
#define _CFFI_PRIM_INT           7
#define _CFFI_PRIM_UINT          8
#define _CFFI_PRIM_LONG          9
#define _CFFI_PRIM_ULONG        10
#define _CFFI_PRIM_LONGLONG     11
#define _CFFI_PRIM_ULONGLONG    12
#define _CFFI_PRIM_FLOAT        13
#define _CFFI_PRIM_DOUBLE       14
#define _CFFI_PRIM_LONGDOUBLE   15

#define _CFFI_PRIM_WCHAR        16
#define _CFFI_PRIM_INT8         17
#define _CFFI_PRIM_UINT8        18
#define _CFFI_PRIM_INT16        19
#define _CFFI_PRIM_UINT16       20
#define _CFFI_PRIM_INT32        21
#define _CFFI_PRIM_UINT32       22
#define _CFFI_PRIM_INT64        23
#define _CFFI_PRIM_UINT64       24
#define _CFFI_PRIM_INTPTR       25
#define _CFFI_PRIM_UINTPTR      26
#define _CFFI_PRIM_PTRDIFF      27
#define _CFFI_PRIM_SIZE         28
#define _CFFI_PRIM_SSIZE        29
#define _CFFI_PRIM_INT_LEAST8   30
#define _CFFI_PRIM_UINT_LEAST8  31
#define _CFFI_PRIM_INT_LEAST16  32
#define _CFFI_PRIM_UINT_LEAST16 33
#define _CFFI_PRIM_INT_LEAST32  34
#define _CFFI_PRIM_UINT_LEAST32 35
#define _CFFI_PRIM_INT_LEAST64  36
#define _CFFI_PRIM_UINT_LEAST64 37
#define _CFFI_PRIM_INT_FAST8    38
#define _CFFI_PRIM_UINT_FAST8   39
#define _CFFI_PRIM_INT_FAST16   40
#define _CFFI_PRIM_UINT_FAST16  41
#define _CFFI_PRIM_INT_FAST32   42
#define _CFFI_PRIM_UINT_FAST32  43
#define _CFFI_PRIM_INT_FAST64   44
#define _CFFI_PRIM_UINT_FAST64  45
#define _CFFI_PRIM_INTMAX       46
#define _CFFI_PRIM_UINTMAX      47

#define _CFFI__NUM_PRIM         48
#define _CFFI__UNKNOWN_PRIM           (-1)
#define _CFFI__UNKNOWN_FLOAT_PRIM     (-2)
#define _CFFI__UNKNOWN_LONG_DOUBLE    (-3)

#define _CFFI__IO_FILE_STRUCT         (-1)


struct _cffi_global_s {
    const char *name;
    void *address;
    _cffi_opcode_t type_op;
    void *size_or_direct_fn;  // OP_GLOBAL_VAR: size, or 0 if unknown
                              // OP_CPYTHON_BLTN_*: addr of direct function
};

struct _cffi_getconst_s {
    unsigned long long value;
    const struct _cffi_type_context_s *ctx;
    int gindex;
};

struct _cffi_struct_union_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_STRUCT_UNION
    int flags;               // _CFFI_F_* flags below
    size_t size;
    int alignment;
    int first_field_index;   // -> _cffi_fields array
    int num_fields;
};
#define _CFFI_F_UNION         0x01   // is a union, not a struct
#define _CFFI_F_CHECK_FIELDS  0x02   // complain if fields are not in the
                                     // "standard layout" or if some are missing
#define _CFFI_F_PACKED        0x04   // for CHECK_FIELDS, assume a packed struct
#define _CFFI_F_EXTERNAL      0x08   // in some other ffi.include()
#define _CFFI_F_OPAQUE        0x10   // opaque

struct _cffi_field_s {
    const char *name;
    size_t field_offset;
    size_t field_size;
    _cffi_opcode_t field_type_op;
};

struct _cffi_enum_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_ENUM
    int type_prim;           // _CFFI_PRIM_xxx
    const char *enumerators; // comma-delimited string
};

struct _cffi_typename_s {
    const char *name;
    int type_index;   /* if opaque, points to a possibly artificial
                         OP_STRUCT which is itself opaque */
};

struct _cffi_type_context_s {
    _cffi_opcode_t *types;
    const struct _cffi_global_s *globals;
    const struct _cffi_field_s *fields;
    const struct _cffi_struct_union_s *struct_unions;
    const struct _cffi_enum_s *enums;
    const struct _cffi_typename_s *typenames;
    int num_globals;
    int num_struct_unions;
    int num_enums;
    int num_typenames;
    const char *const *includes;
    int num_types;
    int flags;      /* future extension */
};

struct _cffi_parse_info_s {
    const struct _cffi_type_context_s *ctx;
    _cffi_opcode_t *output;
    unsigned int output_size;
    size_t error_location;
    const char *error_message;
};

struct _cffi_externpy_s {
    const char *name;
    size_t size_of_result;
    void *reserved1, *reserved2;
};

#ifdef _CFFI_INTERNAL
static int parse_c_type(struct _cffi_parse_info_s *info, const char *input);
static int search_in_globals(const struct _cffi_type_context_s *ctx,
                             const char *search, size_t search_len);
static int search_in_struct_unions(const struct _cffi_type_context_s *ctx,
                                   const char *search, size_t search_len);
#endif

/* this block of #ifs should be kept exactly identical between
   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py
   and cffi/_cffi_include.h */
#if defined(_MSC_VER)
# include <malloc.h>   /* for alloca() */
# if _MSC_VER < 1600   /* MSVC < 2010 */
   typedef __int8 int8_t;
   typedef __int16 int16_t;
   typedef __int32 int32_t;
   typedef __int64 int64_t;
   typedef unsigned __int8 uint8_t;
   typedef unsigned __int16 uint16_t;
   typedef unsigned __int32 uint32_t;
   typedef unsigned __int64 uint64_t;
   typedef __int8 int_least8_t;
   typedef __int16 int_least16_t;
   typedef __int32 int_least32_t;
   typedef __int64 int_least64_t;
   typedef unsigned __int8 uint_least8_t;
   typedef unsigned __int16 uint_least16_t;
   typedef unsigned __int32 uint_least32_t;
   typedef unsigned __int64 uint_least64_t;
   typedef __int8 int_fast8_t;
   typedef __int16 int_fast16_t;
   typedef __int32 int_fast32_t;
   typedef __int64 int_fast64_t;
   typedef unsigned __int8 uint_fast8_t;
   typedef unsigned __int16 uint_fast16_t;
   typedef unsigned __int32 uint_fast32_t;
   typedef unsigned __int64 uint_fast64_t;
   typedef __int64 intmax_t;
   typedef unsigned __int64 uintmax_t;
# else
#  include <stdint.h>
# endif
# if _MSC_VER < 1800   /* MSVC < 2013 */
#  ifndef __cplusplus
    typedef unsigned char _Bool;
#  endif
# endif
#else
# include <stdint.h>
# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)
#  include <alloca.h>
# endif
#endif

#ifdef __GNUC__
# define _CFFI_UNUSED_FN  __attribute__((unused))
#else
# define _CFFI_UNUSED_FN  /* nothing */
#endif

#ifdef __cplusplus
# ifndef _Bool
   typedef bool _Bool;   /* semi-hackish: C++ has no _Bool; bool is builtin */
# endif
#endif

/**********  CPython-specific section  **********/
#ifndef PYPY_VERSION


#if PY_MAJOR_VERSION >= 3
# define PyInt_FromLong PyLong_FromLong
#endif

#define _cffi_from_c_double PyFloat_FromDouble
#define _cffi_from_c_float PyFloat_FromDouble
#define _cffi_from_c_long PyInt_FromLong
#define _cffi_from_c_ulong PyLong_FromUnsignedLong
#define _cffi_from_c_longlong PyLong_FromLongLong
#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong

#define _cffi_to_c_double PyFloat_AsDouble
#define _cffi_to_c_float PyFloat_AsDouble

#define _cffi_from_c_int(x, type)                                        \
    (((type)-1) > 0 ? /* unsigned */                                     \
        (sizeof(type) < sizeof(long) ?                                   \
            PyInt_FromLong((long)x) :                                    \
         sizeof(type) == sizeof(long) ?                                  \
            PyLong_FromUnsignedLong((unsigned long)x) :                  \
            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \
        (sizeof(type) <= sizeof(long) ?                                  \
            PyInt_FromLong((long)x) :                                    \
            PyLong_FromLongLong((long long)x)))

#define _cffi_to_c_int(o, type)                                          \
    ((type)(                                                             \
     sizeof(type) == 1 ? (((type)-1) > 0 ? (type)_cffi_to_c_u8(o)        \
                                         : (type)_cffi_to_c_i8(o)) :     \
     sizeof(type) == 2 ? (((type)-1) > 0 ? (type)_cffi_to_c_u16(o)       \
                                         : (type)_cffi_to_c_i16(o)) :    \
     sizeof(type) == 4 ? (((type)-1) > 0 ? (type)_cffi_to_c_u32(o)       \
                                         : (type)_cffi_to_c_i32(o)) :    \
     sizeof(type) == 8 ? (((type)-1) > 0 ? (type)_cffi_to_c_u64(o)       \
                                         : (type)_cffi_to_c_i64(o)) :    \
     (Py_FatalError("unsupported size for type " #type), (type)0)))

#define _cffi_to_c_i8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[1])
#define _cffi_to_c_u8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[2])
#define _cffi_to_c_i16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[3])
#define _cffi_to_c_u16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[4])
#define _cffi_to_c_i32                                                   \
                 ((int(*)(PyObject *))_cffi_exports[5])
#define _cffi_to_c_u32                                                   \
                 ((unsigned int(*)(PyObject *))_cffi_exports[6])
#define _cffi_to_c_i64                                                   \
                 ((long long(*)(PyObject *))_cffi_exports[7])
#define _cffi_to_c_u64                                                   \
                 ((unsigned long long(*)(PyObject *))_cffi_exports[8])
#define _cffi_to_c_char                                                  \
                 ((int(*)(PyObject *))_cffi_exports[9])
#define _cffi_from_c_pointer                                             \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[10])
#define _cffi_to_c_pointer                                               \
    ((char *(*)(PyObject *, struct _cffi_ctypedescr *))_cffi_exports[11])
#define _cffi_get_struct_layout                                          \
    not used any more
#define _cffi_restore_errno                                              \
    ((void(*)(void))_cffi_exports[13])
#define _cffi_save_errno                                                 \
    ((void(*)(void))_cffi_exports[14])
#define _cffi_from_c_char                                                \
    ((PyObject *(*)(char))_cffi_exports[15])
#define _cffi_from_c_deref                                               \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[16])
#define _cffi_to_c                                                       \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[17])
#define _cffi_from_c_struct                                              \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[18])
#define _cffi_to_c_wchar_t                                               \
    ((wchar_t(*)(PyObject *))_cffi_exports[19])
#define _cffi_from_c_wchar_t                                             \
    ((PyObject *(*)(wchar_t))_cffi_exports[20])
#define _cffi_to_c_long_double                                           \
    ((long double(*)(PyObject *))_cffi_exports[21])
#define _cffi_to_c__Bool                                                 \
    ((_Bool(*)(PyObject *))_cffi_exports[22])
#define _cffi_prepare_pointer_call_argument                              \
    ((Py_ssize_t(*)(struct _cffi_ctypedescr *,                           \
                    PyObject *, char **))_cffi_exports[23])
#define _cffi_convert_array_from_object                                  \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[24])
#define _CFFI_CPIDX  25
#define _cffi_call_python                                                \
    ((void(*)(struct _cffi_externpy_s *, char *))_cffi_exports[_CFFI_CPIDX])
#define _CFFI_NUM_EXPORTS 26

struct _cffi_ctypedescr;

static void *_cffi_exports[_CFFI_NUM_EXPORTS];

#define _cffi_type(index)   (                           \
    assert((((uintptr_t)_cffi_types[index]) & 1) == 0), \
    (struct _cffi_ctypedescr *)_cffi_types[index])

static PyObject *_cffi_init(const char *module_name, Py_ssize_t version,
                            const struct _cffi_type_context_s *ctx)
{
    PyObject *module, *o_arg, *new_module;
    void *raw[] = {
        (void *)module_name,
        (void *)version,
        (void *)_cffi_exports,
        (void *)ctx,
    };

    module = PyImport_ImportModule("_cffi_backend");
    if (module == NULL)
        goto failure;

    o_arg = PyLong_FromVoidPtr((void *)raw);
    if (o_arg == NULL)
        goto failure;

    new_module = PyObject_CallMethod(
        module, (char *)"_init_cffi_1_0_external_module", (char *)"O", o_arg);

    Py_DECREF(o_arg);
    Py_DECREF(module);
    return new_module;

  failure:
    Py_XDECREF(module);
    return NULL;
}

/**********  end CPython-specific section  **********/
#else
_CFFI_UNUSED_FN
static void (*_cffi_call_python_org)(struct _cffi_externpy_s *, char *);
# define _cffi_call_python  _cffi_call_python_org
#endif


#define _cffi_array_len(array)   (sizeof(array) / sizeof((array)[0]))

#define _cffi_prim_int(size, sign)                                      \
    ((size) == 1 ? ((sign) ? _CFFI_PRIM_INT8  : _CFFI_PRIM_UINT8)  :    \
     (size) == 2 ? ((sign) ? _CFFI_PRIM_INT16 : _CFFI_PRIM_UINT16) :    \
     (size) == 4 ? ((sign) ? _CFFI_PRIM_INT32 : _CFFI_PRIM_UINT32) :    \
     (size) == 8 ? ((sign) ? _CFFI_PRIM_INT64 : _CFFI_PRIM_UINT64) :    \
     _CFFI__UNKNOWN_PRIM)

#define _cffi_prim_float(size)                                          \
    ((size) == sizeof(float) ? _CFFI_PRIM_FLOAT :                       \
     (size) == sizeof(double) ? _CFFI_PRIM_DOUBLE :                     \
     (size) == sizeof(long double) ? _CFFI__UNKNOWN_LONG_DOUBLE :       \
     _CFFI__UNKNOWN_FLOAT_PRIM)

#define _cffi_check_int(got, got_nonpos, expected)      \
    ((got_nonpos) == (expected <= 0) &&                 \
     (got) == (unsigned long long)expected)

#ifdef MS_WIN32
# define _cffi_stdcall  __stdcall
#else
# define _cffi_stdcall  /* nothing */
#endif

#ifdef __cplusplus
}
#endif

/************************************************************/

//
//  main.c
//  ptu-read-tests
//
//  Created by Raphaël Proux on 03/10/2017.
//  Copyright © 2017 Raphaël Proux. All rights reserved.
//

#include <stdio.h>
#include <stdlib.h>

// RecordTypes
#define rtPicoHarpT3     0x00010303    // (SubID = $00 ,RecFmt: $01) (V1), T-Mode: $03 (T3), HW: $03 (PicoHarp)
#define rtPicoHarpT2     0x00010203    // (SubID = $00 ,RecFmt: $01) (V1), T-Mode: $02 (T2), HW: $03 (PicoHarp)
#define rtHydraHarpT3    0x00010304    // (SubID = $00 ,RecFmt: $01) (V1), T-Mode: $03 (T3), HW: $04 (HydraHarp)
#define rtHydraHarpT2    0x00010204    // (SubID = $00 ,RecFmt: $01) (V1), T-Mode: $02 (T2), HW: $04 (HydraHarp)
#define rtHydraHarp2T3   0x01010304    // (SubID = $01 ,RecFmt: $01) (V2), T-Mode: $03 (T3), HW: $04 (HydraHarp)
#define rtHydraHarp2T2   0x01010204    // (SubID = $01 ,RecFmt: $01) (V2), T-Mode: $02 (T2), HW: $04 (HydraHarp)
#define rtTimeHarp260NT3 0x00010305    // (SubID = $00 ,RecFmt: $01) (V2), T-Mode: $03 (T3), HW: $05 (TimeHarp260N)
#define rtTimeHarp260NT2 0x00010205    // (SubID = $00 ,RecFmt: $01) (V2), T-Mode: $02 (T2), HW: $05 (TimeHarp260N)
#define rtTimeHarp260PT3 0x00010306    // (SubID = $00 ,RecFmt: $01) (V1), T-Mode: $02 (T3), HW: $06 (TimeHarp260P)
#define rtTimeHarp260PT2 0x00010206    // (SubID = $00 ,RecFmt: $01) (V1), T-Mode: $02 (T2), HW: $06 (TimeHarp260P)

// How big the file chunking will be
#define RECORD_CHUNK 512

// ================================================
// Buffer for keeping track of records
// ================================================
typedef struct {
    uint64_t timetag;
    int channel;
} record;

typedef struct {
    record records[RECORD_CHUNK]; // using this will improve memory locality
    size_t head;  // to keep track of what was the last read record in buffer
    size_t count; // if don't have enough photons, for example due to many records being oflcorrection flags
} record_buf_t;

void record_buf_reset(record_buf_t *buffer) {
    buffer->head = 0;
    buffer->count = 0;
}

void record_buf_pop(record_buf_t *buffer, uint64_t *timetag, int *channel) {
    size_t head = buffer->head;
    *timetag = buffer->records[head].timetag;
    *channel = buffer->records[head].channel;
    buffer->head = head + 1;
}

void record_buf_push(record_buf_t *buffer, uint64_t timetag, int channel) {
    size_t count = buffer->count;
    buffer->records[count].timetag = timetag;
    buffer->records[count].channel = channel;
    buffer->count = count + 1;
}
// ================================================
// END Buffer for keeping track of records
// ================================================

// ====================================================================
// CIRCULAR BUFFER Structure for use with the g2 algorithm based on it
// ====================================================================
typedef struct {
    uint64_t *buffer;
    size_t head;
    size_t count;
    size_t size; //of the buffer
} circular_buf_t;


void circular_buf_reset(circular_buf_t * cbuf);
void circular_buf_put(circular_buf_t * cbuf, uint64_t data);
void circular_buf_oldest(circular_buf_t * cbuf, uint64_t * data);


void circular_buf_reset(circular_buf_t * cbuf)
{
    if(cbuf) {
        cbuf->head = 0;
        cbuf->count = 0;
    }
}

void circular_buf_put(circular_buf_t * cbuf, uint64_t data)
{
    if(cbuf) {
        cbuf->buffer[cbuf->head] = data;
        cbuf->head = (cbuf->head + 1) % cbuf->size;
        if(cbuf->count < cbuf->size) {
            cbuf->count = cbuf->count + 1;
        }
    }
}

void circular_buf_oldest(circular_buf_t * cbuf, uint64_t * data) {
    // CAUTION: Even if the buffer is empty oldest will return whatever
    // is in buffer[0]. We do so because it is conveninet for our specific
    // application but it can be catastrophic.
    // TAKE HOME MESSAGE: Don't use this implementation as is for anything
    // other than computing g2.
    if(cbuf && data) {
        if(cbuf->count < cbuf->size) {
            *data = cbuf->buffer[0];
        } else {
            *data = cbuf->buffer[cbuf->head];
        }
    }
}
// ============================
// END OF CIRCULAR BUFFER
// ============================


// ====================================================================
// CHAINED LIST BUFFER Structure for use with the dummy g2 algorithm (calculate_g2)
// ====================================================================

// this 'node' structure is a chained list to be used with the buffers. It is easy to add an item 
// at the end and read+remove an item at the beginning (see the three functions below).
typedef struct node {
    uint64_t val;
    struct node * next;
} node_t;

void head_init(node_t** head, int* length) {
    // initialize a chained list with value 0 and length 0.
    *head = malloc(sizeof(node_t));
    (*head)->val = 0;
    (*head)->next = NULL;
    *length = 0;
}

void push(node_t * head, uint64_t val, int* length) {
    // add an item at the end of the list
    node_t * current = head;
    while (current->next != NULL) {
        current = current->next;
    }
    
    // now we can add a new variable
    current->next = malloc(sizeof(node_t));
    current->next->val = val;
    current->next->next = NULL;
    *length = *length + 1;
}

uint64_t pop(node_t * head, int* length) {
    // remove the first info item (second in the list) from the list, returning its value
    // remember that, for simplicity, we keep the very first item of the list alive so we don't need to recreate one each time the list becomes empty.
    uint64_t retval = 0;
    node_t * next_node = NULL;
    
    if (head->next == NULL) {
        return 0;
    }
    
    next_node = head->next->next;
    retval = head->next->val;
    free(head->next);
    head->next = next_node;
    *length = *length - 1;
    
    return retval;
}

// ============================
// END OF DUMMY G2 BUFFER
// ============================


int c_fseek(FILE *filehandle, long int offset)
{
    return fseek(filehandle, offset, SEEK_SET);
}

void ProcessPHT2(FILE* filehandle, record_buf_t *buffer,  uint64_t *oflcorrection)
{
    /*
     ProcessPHT2() reads the next records of a file until it finds a photon, and then returns.
     Inputs:
         filehandle         FILE pointer with an open record file to read the photons
         oflcorrection      pointer to an unsigned integer 64 bits. Will record the time correction in the timetags due to overflow (see output for details).
         buffer             buffer from which to read the next record (file chunk read buffer)
     Outputs:
         filehandle         FILE pointer with reader at the position of last analysed record
         oflcorrection      offset time on the timetags read in the file, due to overflows.
         buffer             buffer of the next chunk of records, containing for each a timetag and a channel number.
                            If a photon is read, timetag of this photon. Otherwise, timetag == 0. It already includes the overflow correction 
                                so the value can be used directly.
                            If a photon is read, channel of this photon. 0 will usually be sync and >= 1 other input channels. If the record is 
                                not a photon, channel == -1 for an overflow record, -2 for a marker record.
     */
    /* FUNCTION TESTED QUICKLY */
    
    const int T2WRAPAROUND = 210698240;
    union
    {
        unsigned int allbits;
        struct
        {
            unsigned time   :28;
            unsigned channel  :4;
        } bits;
        
    } Record;
    unsigned int markers;
    uint32_t TTTRRecord[RECORD_CHUNK];
    
    fread(&TTTRRecord, RECORD_CHUNK, sizeof(uint32_t), filehandle);
    for(size_t i = 0; i < RECORD_CHUNK; i++) {
        Record.allbits = TTTRRecord[i];
        
        if(Record.bits.channel == 0xF) //this means we have a special record
        {
            //in a special record the lower 4 bits of time are marker bits
            markers = Record.bits.time & 0xF;
            if(markers == 0) //this means we have an overflow record
            {
                record_buf_push(buffer, 0, -1);
                *oflcorrection += T2WRAPAROUND; // unwrap the time tag overflow
            }
            else //a marker
            {
                //Strictly, in case of a marker, the lower 4 bits of time are invalid
                //because they carry the marker bits. So one could zero them out.
                //However, the marker resolution is only a few tens of nanoseconds anyway,
                //so we can just ignore the few picoseconds of error.
                record_buf_push(buffer, *oflcorrection + Record.bits.time, -2);
            }
        }
        else
        {
            if((int)Record.bits.channel > 4) //Should not occur
            {
                record_buf_push(buffer, 0, -3);
            }
            else
            {
                record_buf_push(buffer,
                                *oflcorrection + Record.bits.time,
                                Record.bits.channel);
            }
        }
    }
}

void ProcessHHT2(FILE* filehandle, int HHVersion, record_buf_t *buffer,  uint64_t *oflcorrection)
{
    /*
     ProcessHHT2() reads the next records of a file until it finds a photon, and then returns.
     Inputs:
         filehandle         FILE pointer with an open record file to read the photons
         HHVersion          Hydrahard version 1 or 2. Depends on record type specification in the header.
         oflcorrection      pointer to an unsigned integer 64 bits. Will record the time correction in the timetags due to overflow (see output for details).
         buffer             buffer from which to read the next record (file chunk read buffer)
     Outputs:
         filehandle         FILE pointer with reader at the position of last analysed record
         oflcorrection      offset time on the timetags read in the file, due to overflows.
         buffer             buffer of the next chunk of records, containing for each a timetag and a channel number.
                            If a photon is read, timetag of this photon. Otherwise, timetag == 0. It already includes the overflow correction 
                                so the value can be used directly.
                            If a photon is read, channel of this photon. 0 will usually be sync and >= 1 other input channels. If the record is 
                                not a photon, channel == -1 for an overflow record, -2 for a marker record.
     */
    /* FUNCTION TESTED */
    
    const uint64_t T2WRAPAROUND_V1 = 33552000;
    const uint64_t T2WRAPAROUND_V2 = 33554432;
    union{
        uint32_t   allbits;
        struct{ unsigned timetag  :25;
            unsigned channel  :6;
            unsigned special  :1; // or sync, if channel==0
        } bits;
    } T2Rec;
    uint32_t TTTRRecord[RECORD_CHUNK];
    
    fread(TTTRRecord, RECORD_CHUNK, sizeof(uint32_t), filehandle);
    for(size_t i = 0; i < RECORD_CHUNK; i++) {
        T2Rec.allbits = TTTRRecord[i];
        
        if(T2Rec.bits.special==1)
        {
            if(T2Rec.bits.channel==0x3F) //an overflow record
            {
                if(HHVersion == 1)
                {
                    record_buf_push(buffer, 0, -1);
                    *oflcorrection += T2WRAPAROUND_V1;
                }
                else
                {
                    //number of overflows is stored in timetag
                    if(T2Rec.bits.timetag==0) //if it is zero it is an old style single overflow
                    {
                        *oflcorrection += T2WRAPAROUND_V2;  //should never happen with new Firmware! ///
                    }
                    else
                    {
                        *oflcorrection += T2WRAPAROUND_V2 * T2Rec.bits.timetag; ///
                    }
                }
                
                record_buf_push(buffer, 0, -1);
            }
            
            if((T2Rec.bits.channel>=1)&&(T2Rec.bits.channel<=15)) //markers
            {
                //Note that actual marker tagging accuracy is only some ns.
                record_buf_push(buffer, *oflcorrection + T2Rec.bits.timetag, -2);
                
            }
            
            else if(T2Rec.bits.channel==0) //sync
            {
                record_buf_push(buffer, *oflcorrection + T2Rec.bits.timetag, T2Rec.bits.channel);
            }
        }
        else //regular input channel
        {
            record_buf_push(buffer,
                            *oflcorrection + T2Rec.bits.timetag,
                            T2Rec.bits.channel + 1);
        }
    }
}


void RecordHHT2(FILE* filehandle)
{
    /*
     RecordHHT2() is a function written for test purposes only. It writes a dummy file containing prearranged photons to test the timetrace and g2 algorithms.
     */
    union {
        uint32_t   allbits;
        struct{ unsigned timetag  :25;
            unsigned channel  :6;
            unsigned special  :1; // or sync, if channel==0
        } bits;
    } T2Rec;
    uint32_t TTTRRecord = 0;
    int i = 0;
    for(i = 0; i < 100; i++){
        if (i % 2){
            T2Rec.bits.special = 0;  // regular input channel
            T2Rec.bits.channel = 0;  // channel number
            T2Rec.bits.timetag = i * 500 + 10;  // timetag in ps
        }
        else {
            T2Rec.bits.special = 1;  // sync channel
            T2Rec.bits.channel = 0;  // sync channel
            T2Rec.bits.timetag = i * 500 + 10;  // timetag in ps
        }
        TTTRRecord = T2Rec.allbits;
        fwrite(&TTTRRecord, 4, 1, filehandle);
    }
}


int next_photon(FILE* filehandle, long long record_type, uint64_t *RecNum, uint64_t NumRecords, record_buf_t *buffer, uint64_t *oflcorrection, uint64_t *timetag, int *channel)
{
    /*
     next_photon() reads the next records of a file until it finds a photon, and then returns.
     Inputs:
         filehandle         FILE pointer with an open record file to read the photons
         record_type        record type which depends on the device which recorded the file (see constants at the beginning of file)
         RecNum             pointer to the index of the record being read
         NumRecords         total number of records
         buffer             pointer to a record_buf_t structure which will be used for chunk file reading
         oflcorrection      pointer to an unsigned integer 64 bits. Will record the time correction in the timetags due to overflow. 
                                At the start of the file should be provided as 0 for initial value.
         timetag            pointer to an unsigned integer 64 bits. Timetag of the next photon (see outputs for details).
         channel            pointer to an integer. Channel of the next photon (see outputs for details).
     Outputs:
         filehandle         FILE pointer with reader at the position of last analysed record
         RecNum             index of last analysed record
         oflcorrection      offset time on the timetags read in the file, due to overflows. Should not be used.
         timetag            timetag of the last photon read. It already includes the overflow correction so the value can  be used directly.
         channel            channel of the last photon read. 0 will usually be sync and >= 1 other input channels.
     Returns:
         1 when found a photon,
         0 when reached end of file.
     */
    
    // We may sacrifice up to RECORD_CHUNK records at the end of the file in order to simplify the logic of the function.
    if (buffer->head < RECORD_CHUNK && buffer->count > 0) { // still have records on buffer
    pop_record:
        do {
            record_buf_pop(buffer, timetag, channel);
            *RecNum += 1;
        } while(*channel < 0 && buffer->head < RECORD_CHUNK);
        
        if (channel >= 0) {
            return 1;
        }
        else { // we run out of buffer before finding a photon
            goto replenish_buffer;
        }
    } else {
    replenish_buffer:
        // we need to replenish the photon pool
        record_buf_reset(buffer);
        if ((*RecNum+RECORD_CHUNK) < NumRecords) {
            switch (record_type) {
                case rtPicoHarpT2:
                    ProcessPHT2(filehandle, buffer, oflcorrection);
                    break;
                case rtPicoHarpT3:
                    //ProcessPHT3(TTTRRecord);
                    break;
                case rtHydraHarpT2:
                    ProcessHHT2(filehandle, 1, buffer, oflcorrection);
                    break;
                case rtHydraHarpT3:
                    //ProcessHHT3(TTTRRecord, 1);
                    break;
                case rtHydraHarp2T2:
                case rtTimeHarp260NT2:
                case rtTimeHarp260PT2:
                    ProcessHHT2(filehandle, 2, buffer, oflcorrection);
                    break;
                case rtHydraHarp2T3:
                case rtTimeHarp260NT3:
                case rtTimeHarp260PT3:
                    //ProcessHHT3(TTTRRecord, 2);
                    break;
                default:
                    return 0;
            }
            goto pop_record;
        }
        else {
            *RecNum = NumRecords - 1;  // for algorithms detecting end of file using RecNum
        }
        return 0; // if we didn't had enough records to replenish
        // the buffer we are done.
    }
    
}

void timetrace(FILE* filehandle, long long record_type, int end_of_header, uint64_t *RecNum, uint64_t NumRecords, uint64_t time_bin_length, uint64_t *time_vector, int *time_trace, uint64_t *RecNum_trace, int nb_of_bins)
{
    /*
         timetrace() computes the timetrace of a given measurement file. It does not differentiate the channel detecting the photons, 
         which are all added together.
         Inputs:
         filehandle         FILE pointer with an open record file to read the photons
         record_type        record type which depends on the device which recorded the file (see constants at the beginning of file)
         end_of_header      offset in bytes to the beginning of the record section in the file
         RecNum             pointer to the index of the record being read
         NumRecords         total number of records
         time_bin_length    length of a time bin of the timetrace in picoseconds
         time_vector        preallocated array used for the x-axis of the timetrace. Should have nb_of_bins elements.
         time_trace         preallocated array used for the timetrace value. Should have nb_of_bins elements.
         RecNum_trace       preallocated array used for the values of RecNum corresponding to the last photon of each time bin. Should have nb_of_bins elements.
         We lose resolution due to the fact that we are reading chunks now.
         nb_of_bins         number of bins for the timetrace (should correspond to the length of the time_trace array)
     Outputs:
         filehandle         FILE pointer with reader at the position of last analysed record
         RecNum             index of last analysed record
         time_trace         calculated timetrace
     */
    // IMPORTANT NOTE: every time in picoseconds
    record_buf_t record_buffer;
    record_buf_reset(&record_buffer);
    
    uint64_t oflcorrection = 0;
    uint64_t timetag = 0;
    int channel = -1;
    uint64_t end_of_bin = 0;
    int add_photon_to_next_bin = 0;
    int i = 0;
    int photon_bool = 1;
    
    // reset file reader
    c_fseek(filehandle, end_of_header);
    
    for (i = 0; i < nb_of_bins; i++)
    {
        time_vector[i] = i * time_bin_length;
        end_of_bin = time_vector[i] + time_bin_length;
        // the last timetag read is in the bin
        if (timetag < end_of_bin) {
            // if we are starting (still didn't read a photon), add_photon_to_next_bin == 0, otherwise, == 1
            time_trace[i] = add_photon_to_next_bin;
            add_photon_to_next_bin = 0;
            
            photon_bool = next_photon(filehandle, record_type, RecNum, NumRecords,
                                      &record_buffer, &oflcorrection, &timetag, &channel);
            while(photon_bool == 1) {
                if(timetag < end_of_bin) { // photon is in the current bin
                    time_trace[i] = time_trace[i] + 1;
                }
                else { // belongs to some further bin (CAUTION: may not be the one immediately after)
                    RecNum_trace[i] = *RecNum;
                    add_photon_to_next_bin = 1;
                    break;
                }
                photon_bool = next_photon(filehandle, record_type, RecNum, NumRecords,
                                          &record_buffer, &oflcorrection, &timetag, &channel);
            }
            if (photon_bool == 0) {  // for the last time bin
                RecNum_trace[i] = *RecNum;
            }
        }
        // not photon found in this time bin.
        else {
            time_trace[i] = 0;
        }
    }
}

void calculate_g2(FILE* filehandle, long long record_type, int end_of_header, uint64_t *RecNum, uint64_t NumRecords, uint64_t RecNum_start, uint64_t RecNum_stop, uint64_t *time_vector, int *histogram, int nb_of_bins, int channel_start, int channel_stop)
{
    /*
     calculate_g2() computes the g2 directly reading the measurement file. It uses a more complex algorithm than calculate_g2_fast(). 
     This function will keep all photons in memory buffers, such that each start photon will be measured in regard of all the stop 
     photons detected in a correlation window around it. This way, the measurement does not stop at the first stop photon but will 
     take into account longer time scales. It is therefore safer to use with high photon count rates.
     Inputs:
         filehandle         FILE pointer with an open record file to read the photons
         record_type        record type which depends on the device which recorded the file (see constants at the beginning of file)
         end_of_header      offset in bytes to the beginning of the record section in the file
         RecNum             pointer to the index of the record being read
         NumRecords         total number of records
         RecNum_start       start of the section of records to analyse for the g2 (in terms of record index)
         RecNum_stop        stop of the section of records to analyse for the g2
         time_vector        precalculated array of times used for the x-axis of the g2 histogram. Should have nb_of_bins + 1 elements.
         histogram          preallocated array of zeros used for the g2 histogram. Should have nb_of_bins elements.
         nb_of_bins         number of bins for the histogram (should correspond to the length of the histogram array)
         channel_start      channel number used for start photons (sync will generally be 0)
         channel_stop       channel number used for stop photons (> 0, often 1)
     Outputs:
         filehandle         FILE pointer with reader at the position of last analysed record
         RecNum             index of last analysed record
         histogram          calculated g2 histogram
     */
    
    record_buf_t record_buffer;
    record_buf_reset(&record_buffer);
    
    node_t* start_buff_head = NULL;
    node_t* stop_buff_head = NULL;
    int start_buff_length = 0;
    int stop_buff_length = 0;
    node_t* stop_corr_buff_head = NULL;
    int stop_corr_buff_length = 0;
    node_t* current = NULL;
    uint64_t correlation_window_end = 0;
    uint64_t start_time = 0;
    uint64_t oflcorrection = 0;
    uint64_t timetag = 0;
    int channel = -1;
    uint64_t i = 0;
    uint64_t correlation_window = 0;
    //    long next_print = 0;
    correlation_window = time_vector[nb_of_bins];
    
    // First item in the chained lists will be kept as anchor and only the 'next' items will contain timetags.
    // This avoids emptying totally the list and having to recreate it when starting to fill it again.
    head_init(&start_buff_head, &start_buff_length);
    head_init(&stop_buff_head, &stop_buff_length);
    head_init(&stop_corr_buff_head, &stop_corr_buff_length);
    
    /*
     This algorithm implies using 3 buffers:
     start_buff_head      : the start photons buffer, where all unused start photons go (to be used later)
     stop_buff_head       : the stop photons buffer, where all unused stop photons go (to be used later)
     stop_corr_buff_head  : the correlation stop photons buffer. This buffer contains all the stop photons which fit 
                            in a correlation window around the selected start photon. For each new start photon, 
                            it needs to be modified removing the old photons which do not fit anymore in the correlation 
                            window and adding the new ones which now fit in the correlation window.
     
     Note that this algorithm supposes the list of photons to be ordered chronologically.
     */
    
    // reset file reader and go to the start position RecNum_start
    c_fseek(filehandle, end_of_header + 4 * RecNum_start);
    *RecNum = RecNum_start;
    
    // while there are still unread photons in the file or unused start photons in the buffer
    while((*RecNum < RecNum_stop && *RecNum < NumRecords) || start_buff_length > 0){
        //        if (*RecNum > next_print){
        //            printf("%ld/%ld\n", *RecNum, RecNum_stop);
        //            next_print = next_print + 1000000;
        //        }
        
        // FIND NEXT START PHOTON
        // first, take first start photon in buffer
        if(start_buff_length > 0){
            start_time = pop(start_buff_head, &start_buff_length);
        }
        // if start buffer is empty, read photons until a start photon is found, and feed stop buffer in the process
        else {
            channel = -1;
            while(channel != channel_start && (*RecNum < RecNum_stop && *RecNum < NumRecords)){
                next_photon(filehandle, record_type, RecNum, NumRecords, &record_buffer, &oflcorrection, &timetag, &channel);
                if (channel == channel_stop){ // store in stop photons buffer
                    push(stop_buff_head, timetag, &stop_buff_length);
                }
                else { // channel 0
                    start_time = timetag;
                }
            }
            if (channel != channel_start && (*RecNum >= RecNum_stop || *RecNum >= NumRecords)) {
                break;
            }
        }
        correlation_window_end = start_time + correlation_window;
        
        // FIND ALL STOP PHOTONS IN CORRELATION WINDOW
        // complete stop photons array with new stop photons from buffer fitting in correlation window
        while(stop_buff_length > 0 && stop_buff_head->next->val < correlation_window_end) {
            push(stop_corr_buff_head, pop(stop_buff_head, &stop_buff_length), &stop_corr_buff_length);
        }
        
        // if stop buffer is empty, read photons until the time gets out of the correlation window, and feed start buffer and the stop photons array in the process
        if (stop_buff_length == 0) {
            while (timetag < correlation_window_end && (*RecNum < RecNum_stop && *RecNum < NumRecords)) {
                next_photon(filehandle, record_type, RecNum, NumRecords, &record_buffer, &oflcorrection, &timetag, &channel);
                // start photon -> store in start photon buffer (to be used later)
                if (channel == channel_start) {
                    push(start_buff_head, timetag, &start_buff_length);
                }
                // stop photon
                else {
                    // qualifies in correlation window -> store in correlation window stop buffer
                    if (timetag < correlation_window_end) {
                        push(stop_corr_buff_head, timetag, &stop_corr_buff_length);
                    }
                    // doesn't qualify -> store in stop photon buffer (to be used later)
                    else {
                        push(stop_buff_head, timetag, &stop_buff_length);
                    }
                }
            }
        }
        // remove stop photons which are out of the correlation window (pop)
        for(i = 0; i < (uint64_t) stop_corr_buff_length; i++) {
            if(stop_corr_buff_head->next->val < start_time) {
                pop(stop_corr_buff_head, &stop_corr_buff_length);
            }
            else {
                break;
            }
        }
        // perform a histogram of the stop times - start time and add it to the main histogram result
        current = stop_corr_buff_head->next;
        while(current != NULL) {
            if (current->val - start_time < correlation_window) {
                i = (uint64_t) (current->val - start_time) * nb_of_bins / correlation_window;
                histogram[i] = histogram[i] + 1;
            }
            current = current->next;
        }
    }
}

void calculate_g2_fast(FILE* filehandle, long long record_type, int end_of_header, uint64_t *RecNum, uint64_t NumRecords, 
                       uint64_t RecNum_start, uint64_t RecNum_stop, uint64_t *time_vector, int *histogram, int nb_of_bins, 
                       int channel_start, int channel_stop)
{
    /*
     calculate_g2_fast() computes the g2 directly reading the measurement file. It uses a simple algorithm which stops at 
     the first stop photon (histogram mode style). This algorithm is fast but loses some information and can exhibit an 
     exponential decay artefact linked to the photon rates.
     Inputs:
         filehandle         FILE pointer with an open record file to read the photons
         record_type        record type which depends on the device which recorded the file (see constants at the beginning of file)
         end_of_header      offset in bytes to the beginning of the record section in the file
         RecNum             pointer to the index of the record being read
         NumRecords         total number of records
         RecNum_start       start of the section of records to analyse for the g2 (in terms of record index)
         RecNum_stop        stop of the section of records to analyse for the g2
         time_vector        precalculated array of times used for the x-axis of the g2 histogram. Should have nb_of_bins + 1 elements.
         histogram          preallocated array of zeros used for the g2 histogram. Should have nb_of_bins elements.
         nb_of_bins         number of bins for the histogram (should correspond to the length of the histogram array)
         channel_start      channel number used for start photons (sync will generally be 0)
         channel_stop       channel number used for stop photons (> 0, often 1)
     Outputs:
         filehandle         FILE pointer with reader at the position of last analysed record
         RecNum             index of last analysed record
         histogram          calculated g2 histogram
     */
    
    record_buf_t record_buffer;
    record_buf_reset(&record_buffer);
    
    uint64_t start_time = 0;
    uint64_t stop_time = 0;
    uint64_t oflcorrection = 0;
    uint64_t timetag = 0;
    int channel = -1;
    size_t i = 0;
    uint64_t correlation_window = 0;
    uint64_t delta=0;
    int photon_bool = 1;
    //    long next_print = 0;
    correlation_window = time_vector[nb_of_bins];
    
    // reset file reader and go to the start position RecNum_start
    c_fseek(filehandle, end_of_header + 4 * RecNum_start);
    *RecNum = RecNum_start;
    
    // go to the start position RecNum_start
    while(*RecNum < RecNum_stop && photon_bool){
        // FIND NEXT START PHOTON
        channel = -1;
        while(*RecNum < RecNum_stop && photon_bool==1 && channel != channel_start){
            photon_bool = next_photon(filehandle, record_type, RecNum, NumRecords,
                                      &record_buffer, &oflcorrection, &timetag, &channel);
        }
        if (*RecNum >= RecNum_stop || *RecNum >= NumRecords){
            break;
        }
        // found a start photon
        else {
            start_time = timetag;
        }
        
        // FIND NEXT STOP PHOTON
        while (*RecNum < RecNum_stop && photon_bool==1 && channel != channel_stop) {
            photon_bool = next_photon(filehandle, record_type, RecNum, NumRecords,
                                      &record_buffer, &oflcorrection, &timetag, &channel);
        }
        // found a stop photon
        if (channel == channel_stop) {
            stop_time = timetag;
        }
        
        // ADD DELAY TO HISTOGRAM
        // add occurence to result histogram if the delay is in the correlation window
        delta = stop_time - start_time;
        if (delta < correlation_window) {
            i = (uint64_t) delta * nb_of_bins / correlation_window;
            histogram[i] = histogram[i] + 1;
        }
    }
}

void calculate_g2_ring(FILE* filehandle, long long record_type, int end_of_header,
                       uint64_t *RecNum, uint64_t NumRecords, uint64_t RecNum_start,
                       uint64_t RecNum_stop, uint64_t *time_vector, int *histogram,
                       int nb_of_bins, int channel_start, int channel_stop,
                       int buffer_size)
{
    /*
     calculate_g2() computes the g2 directly reading the measurement file. It uses a more complex algorithm than calculate_g2_fast(). 
     This function will keep all photons in memory buffers, such that each start photon will be measured in regard of all the stop 
     photons detected in a correlation window around it. This way, the measurement does not stop at the first stop photon but will 
     take into account longer time scales. It is therefore safer to use with high photon count rates.
     Inputs:
         filehandle         FILE pointer with an open record file to read the photons
         record_type        record type which depends on the device which recorded the file (see constants at the beginning of file)
         end_of_header      offset in bytes to the beginning of the record section in the file
         RecNum             pointer to the index of the record being read
         NumRecords         total number of records
         RecNum_start       start of the section of records to analyse for the g2 (in terms of record index)
         RecNum_stop        stop of the section of records to analyse for the g2
         time_vector        precalculated array of times used for the x-axis of the g2 histogram. Should have nb_of_bins + 1 elements.
         histogram          preallocated array of zeros used for the g2 histogram. Should have nb_of_bins elements.
         nb_of_bins         number of bins for the histogram (should correspond to the length of the histogram array)
         channel_start      channel number used for start photons (sync will generally be 0)
         channel_stop       channel number used for stop photons (> 0, often 1)
         buffer_size        Size of the ring buffer
     Outputs:
         filehandle         FILE pointer with reader at the position of last analysed record
         RecNum             index of last analysed record
         histogram          calculated g2 histogram
     */
    
    record_buf_t record_buffer;
    record_buf_reset(&record_buffer);
    
    uint64_t oflcorrection = 0;
    uint64_t timetag = 0;
    uint64_t oldest_timetag;
    int channel = -1;
    
    uint64_t i;  // loop indexing
    uint64_t idx;  // index for histogram
    
    uint64_t delta;
    uint64_t new_correlation_window;
    uint64_t min_correlation_window = 18e18;  // almost 2^64
    uint64_t max_correlation_window = time_vector[nb_of_bins];
    
    int photon_bool = 1;
    
    // reset file reader and go to the start position RecNum_start
    c_fseek(filehandle, end_of_header + 4 * RecNum_start);
    *RecNum = RecNum_start;
    
    // Prepare the circular buffer for the start photons
    circular_buf_t cbuf;
    cbuf.size = buffer_size;
    circular_buf_reset(&cbuf);
    cbuf.buffer = calloc(cbuf.size, sizeof(uint64_t)); // set memory to zero so we have a proper
    // starting time.
    
    // Read all the photons
    photon_bool = next_photon(filehandle, record_type, RecNum, NumRecords,
                              &record_buffer, &oflcorrection, &timetag, &channel);
    
    while(photon_bool==1 && *RecNum < RecNum_stop){
        photon_bool = next_photon(filehandle, record_type, RecNum, NumRecords,
                                  &record_buffer, &oflcorrection, &timetag, &channel);
        
        if (channel == channel_start) {
            circular_buf_put(&cbuf, timetag);
            circular_buf_oldest(&cbuf, &oldest_timetag);
            new_correlation_window = timetag - oldest_timetag;
            
            if (new_correlation_window < min_correlation_window) {
                min_correlation_window = new_correlation_window;
            }
        }
        
        if (channel == channel_stop) {
            for(i = 0; i < cbuf.count; i++) {
                delta = timetag - cbuf.buffer[i];
                if (delta < max_correlation_window) {
                    idx = (uint64_t)(delta * nb_of_bins / max_correlation_window);
                    histogram[idx] = histogram[idx] + 1;
                }
            }
        }
    }
    free(cbuf.buffer);
}


/************************************************************/

static void *_cffi_types[] = {
/*  0 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // FILE *()(int, char const *)
/*  1 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7), // int
/*  2 */ _CFFI_OP(_CFFI_OP_POINTER, 53), // char const *
/*  3 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  4 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1), // int()(FILE *)
/*  5 */ _CFFI_OP(_CFFI_OP_POINTER, 52), // FILE *
/*  6 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  7 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1), // int()(FILE *, long)
/*  8 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/*  9 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 9), // long
/* 10 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 11 */ _CFFI_OP(_CFFI_OP_FUNCTION, 54), // void()(FILE *, long long, int, uint64_t *, uint64_t, uint64_t, uint64_t *, int *, uint64_t *, int)
/* 12 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 13 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 11), // long long
/* 14 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 15 */ _CFFI_OP(_CFFI_OP_POINTER, 16), // uint64_t *
/* 16 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24), // uint64_t
/* 17 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 18 */ _CFFI_OP(_CFFI_OP_NOOP, 15),
/* 19 */ _CFFI_OP(_CFFI_OP_POINTER, 1), // int *
/* 20 */ _CFFI_OP(_CFFI_OP_NOOP, 15),
/* 21 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 22 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 23 */ _CFFI_OP(_CFFI_OP_FUNCTION, 54), // void()(FILE *, long long, int, uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t *, int *, int, int, int)
/* 24 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 25 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 11),
/* 26 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 27 */ _CFFI_OP(_CFFI_OP_NOOP, 15),
/* 28 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 29 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 30 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 31 */ _CFFI_OP(_CFFI_OP_NOOP, 15),
/* 32 */ _CFFI_OP(_CFFI_OP_NOOP, 19),
/* 33 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 34 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 35 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 36 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 37 */ _CFFI_OP(_CFFI_OP_FUNCTION, 54), // void()(FILE *, long long, int, uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t *, int *, int, int, int, int)
/* 38 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
/* 39 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 11),
/* 40 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 41 */ _CFFI_OP(_CFFI_OP_NOOP, 15),
/* 42 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 43 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 44 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 24),
/* 45 */ _CFFI_OP(_CFFI_OP_NOOP, 15),
/* 46 */ _CFFI_OP(_CFFI_OP_NOOP, 19),
/* 47 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 48 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 49 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 50 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 51 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 52 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 0), // FILE
/* 53 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 2), // char
/* 54 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 0), // void
};

static int _cffi_d_c_fseek(FILE * x0, long x1)
{
  return c_fseek(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_c_fseek(PyObject *self, PyObject *args)
{
  FILE * x0;
  long x1;
  Py_ssize_t datasize;
  int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "c_fseek", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (FILE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(5), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long);
  if (x1 == (long)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = c_fseek(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_c_fseek _cffi_d_c_fseek
#endif

static void _cffi_d_calculate_g2(FILE * x0, long long x1, int x2, uint64_t * x3, uint64_t x4, uint64_t x5, uint64_t x6, uint64_t * x7, int * x8, int x9, int x10, int x11)
{
  calculate_g2(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_calculate_g2(PyObject *self, PyObject *args)
{
  FILE * x0;
  long long x1;
  int x2;
  uint64_t * x3;
  uint64_t x4;
  uint64_t x5;
  uint64_t x6;
  uint64_t * x7;
  int * x8;
  int x9;
  int x10;
  int x11;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;
  PyObject *arg8;
  PyObject *arg9;
  PyObject *arg10;
  PyObject *arg11;

  if (!PyArg_UnpackTuple(args, "calculate_g2", 12, 12, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &arg10, &arg11))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (FILE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(5), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long long);
  if (x1 == (long long)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(15), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (uint64_t *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(15), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, uint64_t);
  if (x4 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  x5 = _cffi_to_c_int(arg5, uint64_t);
  if (x5 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  x6 = _cffi_to_c_int(arg6, uint64_t);
  if (x6 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(15), arg7, (char **)&x7);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x7 = (uint64_t *)alloca((size_t)datasize);
    memset((void *)x7, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x7, _cffi_type(15), arg7) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(19), arg8, (char **)&x8);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x8 = (int *)alloca((size_t)datasize);
    memset((void *)x8, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x8, _cffi_type(19), arg8) < 0)
      return NULL;
  }

  x9 = _cffi_to_c_int(arg9, int);
  if (x9 == (int)-1 && PyErr_Occurred())
    return NULL;

  x10 = _cffi_to_c_int(arg10, int);
  if (x10 == (int)-1 && PyErr_Occurred())
    return NULL;

  x11 = _cffi_to_c_int(arg11, int);
  if (x11 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { calculate_g2(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_calculate_g2 _cffi_d_calculate_g2
#endif

static void _cffi_d_calculate_g2_fast(FILE * x0, long long x1, int x2, uint64_t * x3, uint64_t x4, uint64_t x5, uint64_t x6, uint64_t * x7, int * x8, int x9, int x10, int x11)
{
  calculate_g2_fast(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_calculate_g2_fast(PyObject *self, PyObject *args)
{
  FILE * x0;
  long long x1;
  int x2;
  uint64_t * x3;
  uint64_t x4;
  uint64_t x5;
  uint64_t x6;
  uint64_t * x7;
  int * x8;
  int x9;
  int x10;
  int x11;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;
  PyObject *arg8;
  PyObject *arg9;
  PyObject *arg10;
  PyObject *arg11;

  if (!PyArg_UnpackTuple(args, "calculate_g2_fast", 12, 12, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &arg10, &arg11))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (FILE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(5), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long long);
  if (x1 == (long long)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(15), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (uint64_t *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(15), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, uint64_t);
  if (x4 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  x5 = _cffi_to_c_int(arg5, uint64_t);
  if (x5 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  x6 = _cffi_to_c_int(arg6, uint64_t);
  if (x6 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(15), arg7, (char **)&x7);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x7 = (uint64_t *)alloca((size_t)datasize);
    memset((void *)x7, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x7, _cffi_type(15), arg7) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(19), arg8, (char **)&x8);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x8 = (int *)alloca((size_t)datasize);
    memset((void *)x8, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x8, _cffi_type(19), arg8) < 0)
      return NULL;
  }

  x9 = _cffi_to_c_int(arg9, int);
  if (x9 == (int)-1 && PyErr_Occurred())
    return NULL;

  x10 = _cffi_to_c_int(arg10, int);
  if (x10 == (int)-1 && PyErr_Occurred())
    return NULL;

  x11 = _cffi_to_c_int(arg11, int);
  if (x11 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { calculate_g2_fast(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_calculate_g2_fast _cffi_d_calculate_g2_fast
#endif

static void _cffi_d_calculate_g2_ring(FILE * x0, long long x1, int x2, uint64_t * x3, uint64_t x4, uint64_t x5, uint64_t x6, uint64_t * x7, int * x8, int x9, int x10, int x11, int x12)
{
  calculate_g2_ring(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_calculate_g2_ring(PyObject *self, PyObject *args)
{
  FILE * x0;
  long long x1;
  int x2;
  uint64_t * x3;
  uint64_t x4;
  uint64_t x5;
  uint64_t x6;
  uint64_t * x7;
  int * x8;
  int x9;
  int x10;
  int x11;
  int x12;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;
  PyObject *arg8;
  PyObject *arg9;
  PyObject *arg10;
  PyObject *arg11;
  PyObject *arg12;

  if (!PyArg_UnpackTuple(args, "calculate_g2_ring", 13, 13, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &arg10, &arg11, &arg12))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (FILE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(5), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long long);
  if (x1 == (long long)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(15), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (uint64_t *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(15), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, uint64_t);
  if (x4 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  x5 = _cffi_to_c_int(arg5, uint64_t);
  if (x5 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  x6 = _cffi_to_c_int(arg6, uint64_t);
  if (x6 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(15), arg7, (char **)&x7);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x7 = (uint64_t *)alloca((size_t)datasize);
    memset((void *)x7, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x7, _cffi_type(15), arg7) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(19), arg8, (char **)&x8);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x8 = (int *)alloca((size_t)datasize);
    memset((void *)x8, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x8, _cffi_type(19), arg8) < 0)
      return NULL;
  }

  x9 = _cffi_to_c_int(arg9, int);
  if (x9 == (int)-1 && PyErr_Occurred())
    return NULL;

  x10 = _cffi_to_c_int(arg10, int);
  if (x10 == (int)-1 && PyErr_Occurred())
    return NULL;

  x11 = _cffi_to_c_int(arg11, int);
  if (x11 == (int)-1 && PyErr_Occurred())
    return NULL;

  x12 = _cffi_to_c_int(arg12, int);
  if (x12 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { calculate_g2_ring(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_calculate_g2_ring _cffi_d_calculate_g2_ring
#endif

static int _cffi_d_fclose(FILE * x0)
{
  return fclose(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_fclose(PyObject *self, PyObject *arg0)
{
  FILE * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (FILE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(5), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = fclose(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_fclose _cffi_d_fclose
#endif

static FILE * _cffi_d_fdopen(int x0, char const * x1)
{
  return fdopen(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_fdopen(PyObject *self, PyObject *args)
{
  int x0;
  char const * x1;
  Py_ssize_t datasize;
  FILE * result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "fdopen", 2, 2, &arg0, &arg1))
    return NULL;

  x0 = _cffi_to_c_int(arg0, int);
  if (x0 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(2), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = fdopen(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(5));
}
#else
#  define _cffi_f_fdopen _cffi_d_fdopen
#endif

static void _cffi_d_timetrace(FILE * x0, long long x1, int x2, uint64_t * x3, uint64_t x4, uint64_t x5, uint64_t * x6, int * x7, uint64_t * x8, int x9)
{
  timetrace(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_timetrace(PyObject *self, PyObject *args)
{
  FILE * x0;
  long long x1;
  int x2;
  uint64_t * x3;
  uint64_t x4;
  uint64_t x5;
  uint64_t * x6;
  int * x7;
  uint64_t * x8;
  int x9;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;
  PyObject *arg8;
  PyObject *arg9;

  if (!PyArg_UnpackTuple(args, "timetrace", 10, 10, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(5), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (FILE *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(5), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, long long);
  if (x1 == (long long)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(15), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (uint64_t *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(15), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, uint64_t);
  if (x4 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  x5 = _cffi_to_c_int(arg5, uint64_t);
  if (x5 == (uint64_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(15), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (uint64_t *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(15), arg6) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(19), arg7, (char **)&x7);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x7 = (int *)alloca((size_t)datasize);
    memset((void *)x7, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x7, _cffi_type(19), arg7) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(15), arg8, (char **)&x8);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x8 = (uint64_t *)alloca((size_t)datasize);
    memset((void *)x8, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x8, _cffi_type(15), arg8) < 0)
      return NULL;
  }

  x9 = _cffi_to_c_int(arg9, int);
  if (x9 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { timetrace(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_timetrace _cffi_d_timetrace
#endif

static const struct _cffi_global_s _cffi_globals[] = {
  { "c_fseek", (void *)_cffi_f_c_fseek, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 7), (void *)_cffi_d_c_fseek },
  { "calculate_g2", (void *)_cffi_f_calculate_g2, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 23), (void *)_cffi_d_calculate_g2 },
  { "calculate_g2_fast", (void *)_cffi_f_calculate_g2_fast, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 23), (void *)_cffi_d_calculate_g2_fast },
  { "calculate_g2_ring", (void *)_cffi_f_calculate_g2_ring, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 37), (void *)_cffi_d_calculate_g2_ring },
  { "fclose", (void *)_cffi_f_fclose, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 4), (void *)_cffi_d_fclose },
  { "fdopen", (void *)_cffi_f_fdopen, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 0), (void *)_cffi_d_fdopen },
  { "timetrace", (void *)_cffi_f_timetrace, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 11), (void *)_cffi_d_timetrace },
};

static const struct _cffi_struct_union_s _cffi_struct_unions[] = {
  { "_IO_FILE", 52, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
};

static const struct _cffi_typename_s _cffi_typenames[] = {
  { "FILE", 52 },
};

static const struct _cffi_type_context_s _cffi_type_context = {
  _cffi_types,
  _cffi_globals,
  NULL,  /* no fields */
  _cffi_struct_unions,
  NULL,  /* no enums */
  _cffi_typenames,
  7,  /* num_globals */
  1,  /* num_struct_unions */
  0,  /* num_enums */
  1,  /* num_typenames */
  NULL,  /* no includes */
  55,  /* num_types */
  0,  /* flags */
};

#ifdef __GNUC__
#  pragma GCC visibility push(default)  /* for -fvisibility= */
#endif

#ifdef PYPY_VERSION
PyMODINIT_FUNC
_cffi_pypyinit__readTTTRRecords(const void *p[])
{
    p[0] = (const void *)0x2601;
    p[1] = &_cffi_type_context;
}
#  ifdef _MSC_VER
     PyMODINIT_FUNC
#  if PY_MAJOR_VERSION >= 3
     PyInit__readTTTRRecords(void) { return NULL; }
#  else
     init_readTTTRRecords(void) { }
#  endif
#  endif
#elif PY_MAJOR_VERSION >= 3
PyMODINIT_FUNC
PyInit__readTTTRRecords(void)
{
  return _cffi_init("_readTTTRRecords", 0x2601, &_cffi_type_context);
}
#else
PyMODINIT_FUNC
init_readTTTRRecords(void)
{
  _cffi_init("_readTTTRRecords", 0x2601, &_cffi_type_context);
}
#endif

#ifdef __GNUC__
#  pragma GCC visibility pop
#endif
